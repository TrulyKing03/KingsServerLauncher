from __future__ import annotations

from pathlib import Path
import hashlib
import json
import re
import tempfile
from typing import Any, Iterable

from .exceptions import ManifestError, VersionResolutionError
from .models import ServerManifest

MANIFEST_FILENAME = ".mcserverlib.json"


def normalize_loader(loader: str) -> str:
    key = loader.strip().lower().replace("-", "").replace("_", "")
    aliases = {
        "vanilla": "vanilla",
        "mojang": "vanilla",
        "paper": "paper",
        "purpur": "purpur",
        "folia": "folia",
        "fabric": "fabric",
        "quilt": "quilt",
        "forge": "forge",
        "neoforge": "neoforge",
        "neo": "neoforge",
    }
    if key not in aliases:
        raise VersionResolutionError(f"Unsupported loader: {loader}")
    return aliases[key]


def is_stable_version(version: str) -> bool:
    lowered = version.lower()
    unstable_tokens = ("snapshot", "alpha", "beta", "rc", "pre")
    return not any(token in lowered for token in unstable_tokens)


def version_key(version: str) -> tuple[tuple[int, Any], ...]:
    parts = re.split(r"[.\-+_]", version)
    keyed: list[tuple[int, Any]] = []
    for part in parts:
        if part.isdigit():
            keyed.append((0, int(part)))
        else:
            keyed.append((1, part))
    return tuple(keyed)


def pick_latest_version(versions: Iterable[str], stable_only: bool = True) -> str:
    values = [value for value in versions if value]
    if stable_only:
        values = [value for value in values if is_stable_version(value)]
    if not values:
        raise VersionResolutionError("No matching versions were found.")
    values.sort(key=version_key)
    return values[-1]


def hash_file(path: Path, algorithm: str) -> str:
    digest = hashlib.new(algorithm)
    with path.open("rb") as handle:
        for chunk in iter(lambda: handle.read(1024 * 1024), b""):
            digest.update(chunk)
    return digest.hexdigest()


def atomic_write_json(path: Path, payload: dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with tempfile.NamedTemporaryFile(
        "w", delete=False, encoding="utf-8", dir=str(path.parent)
    ) as tmp:
        json.dump(payload, tmp, indent=2, sort_keys=False)
        tmp.write("\n")
        temp_name = tmp.name
    Path(temp_name).replace(path)


def load_json(path: Path) -> dict[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def load_manifest(instance_dir: Path) -> ServerManifest:
    manifest_path = instance_dir / MANIFEST_FILENAME
    if not manifest_path.exists():
        raise ManifestError(
            f"Manifest not found at {manifest_path}. Install a server first."
        )
    payload = load_json(manifest_path)
    return ServerManifest.from_dict(payload)


def save_manifest(instance_dir: Path, manifest: ServerManifest) -> Path:
    manifest_path = instance_dir / MANIFEST_FILENAME
    atomic_write_json(manifest_path, manifest.to_dict())
    return manifest_path


def write_eula(instance_dir: Path, accepted: bool) -> None:
    text = (
        "# Generated by mcserverlib\n"
        f"eula={'true' if accepted else 'false'}\n"
    )
    (instance_dir / "eula.txt").write_text(text, encoding="utf-8")


def write_server_properties(instance_dir: Path, properties: dict[str, str]) -> None:
    lines = [f"{k}={v}" for k, v in properties.items()]
    (instance_dir / "server.properties").write_text(
        "\n".join(lines) + "\n",
        encoding="utf-8",
    )
